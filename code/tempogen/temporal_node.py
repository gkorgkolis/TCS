"""  
An effort to build a custom time-series generator.
Main reasons for this endeavor is some abnormal behavior we noticed on data generated by the CDML generative framework, 
together with some irregularities in the data generator of the Causal Pretraining model. The idea in a nutshell is to implement 
a Structural Causal Model (SCM) for time-series generation based on the definitions given by (Runge et al) in [*] 
The main expected outcomes of this mechanism is to have more control & clarity on the graph and time-series generation, while 
maintaining a theorically sound and clear foundation. 

Assumptions:

    - causal stationatity: the graph structure and the noise distribution of the SCM does not change during time
    - causal sufficiency: all possible causes of a variable are observed - there are no latent confounders of any two observed variables
    ...
"""

import string
import sys

import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
import pandas as pd
import seaborn as sns
import torch
from tqdm import trange

from tempogen.functional_utils import (_torch_exp, _torch_identity,
                                       _torch_linear, _torch_linear_relu,
                                       _torch_linear_sigmoid,
                                       _torch_linear_tanh, _torch_pow,
                                       _torch_sin, _torch_tanh)

sys.path.append(".")

rng = np.random.default_rng()


# ====================================================================================================================================

#     ___________________________________________ Class representing the temporal nodes ___________________________________________

# ====================================================================================================================================


class TempNode:
    """
    Represent the parameterized node of a SCM. Implemented through PyTorch.
    
    Attributes:
        -- Graph --
        **causal_structure** : the causal structure to which the temp node belongs, as a TempCausalStructure instance; 
            used to derive structural ingormation;
        **name** : the name of the node in the causal structure;
        **pa** : the parents of the node; considering causal stationarity, these parents do not change during time; 
            each parent is represented by a Pandas DataFrame w/ two keys: parent variable name | corresponding lag;
        
        -- Node --
        **x** : the current value of the variable corresponding to the node   
        **func** : the functionaldependency of the node; usually a torch function; default to *torch.nn.functional.linear* ;
            each provided function should receive as input a list with the parent values and output a scalar value;

        -- Noise --
        **z** : the current noise value of the node
        **z_distribution** : the distribution followed by the noise variable; must be a "torch.distributions" object.
        **z_type** : the type of noise, which for now can either "additive" or "multiplicative".

    """
    
    def  __init__(
            self, 
            causal_structure, 
            name,
            func=None,
            z_distribution=None,
            z_type=None
    ) -> None:
        """
        Initializes a TempNode object.

        Args:
        causal_structure (TempCausalStructure) : the causal structure to which the temp node belongs; 
                            used to derive structural ingormation;
        name (str) : the name of the node in the causal structure;
        func (any) : the functionaldependency of the node; usually a torch function; default to torch.nn.Linear layer;
                           each provided function should receive as input a list with the parent values and output a scalar value;
                           (a torch.tensor object of shape [1]);
        z_distribution (torch.distributions) : the noise distribution of the node; should be torch.distributions instance;
                            defults to *torch.distributions.uniform.Uniform(low=-0.5, high=0.5)*;
        z_type (str) : the type of the noise application; currenly supporting *additive* and *multiplicative*; defaults to *additive*; 
        """
        # -- graph --
        self.causal_structure = causal_structure
        self.name = name
        self.pa = causal_structure.parent_info[name]

        # -- node --
        self.x = 0
        if not func:
            func = _torch_linear_sigmoid
        self.func = func
        
        # -- noise --
        self.z = 0
        if not z_distribution:
            # z_distribution = torch.distributions.uniform.Uniform(low=-0.5, high=0.5)
            # s2 = torch.distributions.uniform.Uniform(low=0.3, high=1)
            z_distribution = torch.distributions.normal.Normal(loc=0, scale=0.25)
        self.z_distribution = z_distribution
        if not z_type:
            z_type = 'additive'
        self.z_type = z_type

        # -- archives --
        self.archive = pd.DataFrame(columns=['x', 'z'])
    

    def forward(self, parent_values) -> torch.Tensor:
        """ 
        Performs a forward pass of ancestral sampling for the current time-step.
        If the node has no parents, it requires no input arguments - it simply samples from its noise distribution.
        If the node has one or more parents, it adds its parent values of the corresponding lag w/ the sampled noise, as described in [*].

        Args
        ----
        parent_values (list) : a list w/ the node's parent values at their corresponding time-step, can be an empty list.

        Return
        ------
        val (torch.Tensor) : the node's value at this current time-step.
        """
        # -- sample noise (scalar) from the node's noise distribution --
        self.z = self.z_distribution.sample()

        # -- calculate the value according to its parent values and its noise distribution, noise type and functional dependency --
        if self.z_type=='additive':
            self.x = self.func(parent_values) + self.z
        
        elif self.z_type=='multiplicative':
            self.x = self.func(parent_values) * self.z

        # Keep the variable and the noise value for reference; for this to work, .foward should only be used once at each time-step
        self.update_archive()

        return(self.x)
    
    
    def update_archive(self):
        self.archive.loc[len(self.archive), :] = (self.x, self.z)


    def reset_archive(self):
        self.archive = pd.DataFrame(columns=['x', 'z'])